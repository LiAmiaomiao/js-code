### 计算机网络

- **OSI七层模型与TCP/IP四层模型**
  - 注：TCP/IP四层模型把应用层、表示层、会话层归为应用层；把数据链路层和物理层归为链路层；所以TCP/IP四层模型有：应用层，传输层，网络层，链路层

![6](https://github.com/LiAmiaomiao/js-code/blob/master/Aimages/6.jpg)


- **UDP**

  - UDP头部包括了
    - 两个十六位的端口号，分别为源端口（可选字段）和目标端口
    - 整个数据报文的长度
    - 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误

  - 特点
    - 面向无连接
      - UDP 想发数据就可以开始发送，不需要像TCP一样进行三次握手，并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。
    - 不可靠性
      - 体现在无连接上，通信都不需要建立连接，想发就发；并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。
    - 高效
      - 在一些实时性要求高的场景，UDP的优点就展现出现了（没有拥塞控制，不需要保证数据不丢失且有序到达）
  - 传输方式：一对多，多对多，多对一，也就是说 UDP 提供了单播，多播，广播的功能。
  - 适用场景：实时性要求高
    - 直播，游戏等

- **TCP**

  - 头部几个重要的字段
    - Sequence number，这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文
    - Acknowledgement Number，这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到
    - Window Size，窗口大小，表示还能接收多少字节的数据，用于流量控制
    - 标识符 
      - URG=1：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。
      - ACK=1：该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一。
      - PSH=1：该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。
      - RST=1：该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求。
      - SYN=1：当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。
      - FIN=1：该字段为一表示此报文段是一个释放连接的请求报文。
  - 三次握手
    - 第一次握手：户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入  SYN-SENT 状态。
    - 第二次握手：服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。
    - 第三次握手：当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功
    - 为什么 TCP 建立连接需要三次握手，明明两次就可以建立起连接？因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。
  - 四次握手
    - 第一次握手：若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。
    - 第二次握手：B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。
    - 第三次握手：B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。
    - 第四次握手：A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 
      2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B
      收到确认应答后，也便进入 CLOSED 状态。
  - ARQ协议：超时重传协议，包括停止等待ARQ和连续ARQ两种协议，通过确认和超时机制保证了数据的正确送达
  - 滑动窗口：帮助 TCP 实现了流量控制的功能
  - 拥塞处理：作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况；包括了四个算法，分别为：慢开始，拥塞避免，快速重传，快速恢复。
  - UPD和TCP的区别：UDP 协议是面向无连接的，也就是说不需要在正式传递数据之前先连接起双方，而TCP建立连接断开连接都需要先需要进行握手；然后 UDP 协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，并且UDP 协议也没有任何控制流量的算法，而TCP通过各种算法保证数据的可靠性，总的来说 UDP 相较于 TCP 更加的轻便高效。

- **HTTP**

  - 构成部分：

    - 请求行（请求方法、URL、协议版本组成）
    - 首部
    - 实体

  - POST和GET的区别：

    - 从技术上说
      - Get 请求能缓存，Post 不能
      - Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里（当然你想写到 `body` 里也是可以的），且会被浏览器保存历史纪录。Post 不会，但是在抓包的情况下都是一样的。
      - URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的
      - Post 支持更多的编码类型且不对数据类型限制
    - 在规范的应用场景上说
      - Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册。
        - 副作用指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。
        - 幂等指发送 M 和 N 次请求（两者不相同且都大于 1），服务器上资源的状态一致，比如注册 10 个和 11 个帐号是不幂等的，对文章进行更改 10 次和 11 次是幂等的。

  - 常用状态码

    - 2XX 成功

      - 200 OK，表示从客户端发来的请求在服务器端被正确处理
      - 204 No content，表示请求成功，但响应报文不含实体的主体部分
      - 205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容
      - 206 Partial Content，进行范围请求

      3XX 重定向

      - 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
      - 302 found，临时性重定向，表示资源临时被分配了新的 URL
      - 303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源
      - 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
      - 307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求

      4XX 客户端错误

      - 400 bad request，请求报文存在语法错误
      - 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
      - 403 forbidden，表示对请求资源的访问被服务器拒绝
      - 404 not found，表示在服务器上没有找到请求的资源

      5XX 服务器错误

      - 500 internal sever error，表示服务器端在执行请求时发生了错误
      - 501 Not Implemented，表示服务器不支持当前请求所需要的某个功能
      - 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求

  - TLS协议：加密

    - 在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。

      - 对称加密
        - 两边拥有相同的秘钥，两边都知道如何将密文加密解密
      - 非对称加密
        - 有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。

    - TLS握手过程

      - 客户端发送一个随机值以及需要的协议和加密方式。

        服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，并且发送自己的证书（如果需要验证客户端证书需要说明）

        客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书

        服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密

  - HTTP/2 通过多路复用、二进制流、Header 压缩等等技术，极大地提高了性能，但是还是存在着问题的

  - QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议